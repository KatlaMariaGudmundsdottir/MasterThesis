\setstretch{1.6}
\sectiontitle{6}{Path Planning Integration}
\lhead{Path Planning Integration} % section header
Prior to the start of this thesis a path planning algorithm had been developed specifically for this system by another student. However that algorithm was in matlab and had not beein incorporated into the code base. 
\newline \newline
The algorithm works by generating paths using geometric motion primitives, including constant curvature arcs and straight segments, constrained by the physical properties of the tendon-driven ribbon. It applies a look-ahead strategy combined with dynamic programming to optimize curvature achanges and minimize total path length. \todo{insert citation to the description of the system by charles}

\subsection{Theory}

\subsection{Methods}
Several strategies for incorporating the MATLAB-based path planning algorithm into the control system were considered. One option was to rewrite the algorithm in C++ and embed it directly into the codebase. However, since the planner is inteded for precomputed paths rather than real-time operation, this approach was deemed unnecessary and inefficient.
\newline \newline
Instead, a more modular approach was adopted: the system codebase was adapted to read a simple CSV file containing path segments defined by arc length and curvature, a file that is generated by the MATLAB path planning algorithm. A dedicated module was implemented to parse this file and interpolate a continuous trajectory. 

\subsection{Implementation}
The \texttt{PathProcessing} module was implemented to parse the file generated by the pathplanning algorithm. The module imports and inerpolates the data from the file containg segment lengths and curvatures. After parsing the file, it stores the values for use in feedforward control and trajectory generation.
\newline \newline
To generate a continuous path, each segment is discretized into steps of length \( \Delta l \), and waypoints are computed based on whether the segment is straight or curved. The path starts at \( (x_0, z_0) = (0, 0) \) with an initial heading \( \gamma = -\frac{\pi}{2} \).

For \textbf{straight segments} (\( |\kappa| < 10^{-6} \)), the position is updated using:
\begin{align}
x_{i+1} &= x_i + \Delta l \cdot \cos(\gamma) \\
z_{i+1} &= z_i - \Delta l \cdot \sin(\gamma)
\end{align}

For \textbf{curved segments} (\( |\kappa| \geq 10^{-6} \)), the radius \( R = \frac{1}{\kappa} \) is used to compute:
\begin{align}
\Delta \gamma &= \Delta l \cdot \kappa \\
x_{i+1} &= x_i + R \left( \sin(\gamma + \Delta \gamma) - \sin(\gamma) \right) \\
z_{i+1} &= z_i + R \left( \cos(\gamma + \Delta \gamma) - \cos(\gamma) \right) \\
\gamma &\leftarrow \gamma + \Delta \gamma
\end{align}

An optional positional offset can also be applied to the generated waypoints to shift the path to the starting point of where the ribbon enters the medium. The resulting list of points. along with curcature information at each step is stored and made available to path following modules. 

\subsection{Results}
\todo{figure of paths}

\subsection{Discussion}

This approach simplifies the integration while keeping the control framework flexible and decoupled from the planning logic.

This modular implementation ensures that path planning remains decoupled from the runtime control logic while providing the necessary trajectory resolution and curvature profile for smooth control.