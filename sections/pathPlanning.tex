\setstretch{1.6}
\sectiontitle{6}{Path Planning Integration}
\lhead{Path Planning Integration} % section header
Prior to the start of this thesis a path planning algorithm had been developed specifically for this system by another student. However that algorithm was in matlab and had not been incorporated into the code base. It was therefore a necessary step to determine how this pathplanning should be incorporated into the system in order to allow path following. This brief section outlines the methodology and implementation of the path planning integration.

\subsection{Description of the Path Planning Algorithm}
The algorithm generates paths by combining geometric primitives, specifically constant curvature arcs and straight-line segments. The generated path is composed of piecewise constant curvature segments, with a non-differentiable curvature profile over time. To construct efficient and safe trajectories, the algorithm uses a look-ahead strategy combined with dynamic programming. At each step, it evaluates multiple motion primitives to connect the current waypoint to the next, considering how different curvature transitions affect the downstream trajectory. The selection aims to minimize the total path length and the number of curvature changes (which relate to crack generation in the tissue). This eventually outputs a list of straight line segments and curvature segments that create a continuous path. For more details on the algorithm see the final report of Charles Hong in appendix D.

\subsection{Methods}
Several strategies for incorporating the MATLAB-based path planning algorithm into the control system were considered. One option was to rewrite the algorithm in C++ and embed it directly into the codebase. However, since the planner is intended for precomputed paths rather than real-time operation, this approach was deemed unnecessary and inefficient.
\newline \newline
Instead, a more modular approach was adopted: the system codebase was adapted to read a simple CSV file containing path segments defined by arc length and curvature, a file that is generated by the MATLAB path planning algorithm. A dedicated module, \texttt{PathProcessing}, was implemented to parse this file and interpolate a continuous trajectory. 

\subsection{Implementation}
The \texttt{PathProcessing} module was implemented to parse the file generated by the pathplanning algorithm. The module imports and interpolates the data from the file containing segment lengths and curvatures. After parsing the file, it stores the values for use in feedforward control and trajectory generation.
\newline \newline
To generate a continuous path, each segment is discretized into steps of length \( \Delta l \), and waypoints are computed based on whether the segment is straight or curved. The path starts at \( (x_0, z_0) = (0, 0) \) with an initial heading \( \gamma = -\frac{\pi}{2} \).

For \textbf{straight segments} (\( |\kappa| < 10^{-6} \)), the position is updated using:
\begin{align}
x_{i+1} &= x_i + \Delta l \cdot \cos(\gamma) \\
z_{i+1} &= z_i - \Delta l \cdot \sin(\gamma)
\end{align}

For \textbf{curved segments} (\( |\kappa| \geq 10^{-6} \)), the radius \( R = \frac{1}{\kappa} \) is used to compute:
\begin{align}
\Delta \gamma &= \Delta l \cdot \kappa \\
x_{i+1} &= x_i + R \left( \sin(\gamma + \Delta \gamma) - \sin(\gamma) \right) \\
z_{i+1} &= z_i + R \left( \cos(\gamma + \Delta \gamma) - \cos(\gamma) \right) \\
\gamma &\leftarrow \gamma + \Delta \gamma
\end{align}

An optional positional offset can also be applied to the generated waypoints to shift the path to the starting point of where the ribbon enters the medium. The resulting list of points. along with curcature information at each step is stored and made available to path following modules. 

\subsection{Results}
The results of the path planning integration can be seen in figure \ref{fig:waypoints}. Each plotted point represents a waypoint generated by the \texttt{PathProcessing} module, based on the optimized path produced by the MATLAB path planning algorithm.

\begin{figure}[H]
    \centering
    \begin{subcaptionbox}{\label{fig:left}}[0.45\linewidth]
        {\includegraphics[width=\linewidth]{images/waypoints/smallcurves2.png}}
    \end{subcaptionbox}
    \hspace{0.05\linewidth}
    \begin{subcaptionbox}{\label{fig:right}}[0.45\linewidth]
        {\includegraphics[width=\linewidth]{images/waypoints/Figure_1.png}}
    \end{subcaptionbox}
    \caption{Two example paths (a) and (b) generated by the path planning algorithm. The plotted points are the interpolated waypoints generated by the \texttt{PathProcessing} module.}
    \label{fig:waypoints}
\end{figure}

\subsection{Discussion}
\subsubsection{Path Planning Algorithm Limitations}

A key limitation , of the the current path planning algorithm when applied to this system is that the planned paths consist of discrete constant-curvature segments joined together, resulting in a continuous path, but non-differentiable curvature profile. In reality, the ribbon cannot switch instantly between different curvatures, these transistions require phsycial deformation over time and space. 
As such, future iterations of the path planning could aim to generate continuously differentiable curvature profiles, potentially by incorporating splines or smooth curvature interpolation methods \cite{fossen_handbook_2011}. This would better reflect the true kinematic capabilities of the device and enable more physically plausible and smoother motions.
\newline \newline
Implementing such improvements was unfortunately beyond the scope of this thesis, where the aim was merely to follow the given paths as closely as possible. However, incorporating more physically realistic curvature transition would certainly improve the overall performance of the system and should likely be prioritized in later iterations of the system.

\subsubsection{Future Work}
Further work could also explore real-time path re-planning based on the current position and orientation of the ribbon and its observed curving capabilities. Not all ribbons exhibit identical curvature capabilities and therefore adaptive re-planning could be an interesting way to compensate for that fact.

\subsection{Conclusion}
The integration of the existing path planning algorithm was done successsfully using a modular approach such that paths can easily be updated or switched out. By passing precomputed path to the \texttt{PathProcessing} module, the system can now follow optimized trajectories while keeping the path logic decoupled from the runtime control. This solution meets the goals of the thesis: enabling path following based on the provided algorithm.


